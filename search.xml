<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[spring AOP 基础]]></title>
      <url>%2F2017%2F02%2F08%2Fspring-aop-1%2F</url>
      <content type="text"><![CDATA[切面编程面向切面编程 AOP(Aspect-Oriented Programming) 是从一个不同的编程方式角度对 面向对象编程 OOP 的完善。在切面编程中，切面是一个关键元素，正如面向对象编程中对象是一个核心元素。切面的功能是使一些跨越对象的逻辑模块化，如 事务管理。 一. 基本概念让我们先了解一下spring AOP 的一些基础概念: aspect(切面): 跨越多个类的共同逻辑，即从多个类中抽出的相同执行模块，如事务管理模块。此处 aspcet 只是概念性关键字， 下面介绍的其他关键字都属于切面的范畴。 join point(连接点): 程序中允许切面执行的时机，如方法执行时，异常处理时。需要注意的是spring只支持方法连接点。 advice(通知): advice 是切面在切点处的执行逻辑，其按照其执行方式可以分成before advice, after advice, after throwing advice, after returning advice, around advice五种。 pointcut(切点): pointcut 定义了切面与连接点的匹配规则。advice 会根据 pointcut 定义的规则去匹配相应的 joint point, 并最终执行 advice 定义的切面逻辑。 introduction(引入): 这应该可以理解成切面编程中一个特殊的功能: 向一个类中引入外部接口和属性，简单地说就是扩展一个类对外暴露的接口。 target object(目标对象): 被切面切入代理逻辑的业务对象。 AOP proxy(切面代理对象): 框架为实现切面生成的动态代理对象。spring 动态代理对象可以分为JDK dynamic proxy 和 CGLIB dynamic proxy。 waving(织入): 指实现切面和目标类进行关联的行为过程，通常 编译,加载,运行 环节都可进行。spring AOP 框架 和 其他 纯 java aop 框架 一样只在运行时进行织入。 这些概念目前看来可能还不大直观，但是不用着急，在后面的样例中我们将逐一详细了解。到时候再回顾来看就肯定清晰了。 二. spring AOP 特点这里让我们简单了解一下 spring AOP 的特点（相较其他 AOP 框架，如 AspectJ 而言）: spring AOP 是一个纯java实现的AOP框架，因此只支持运行时进行切面织入; spring 目前只支持 方法级别的切点(method join point)（field join point 实现 可以考虑使用 AspectJ 框架）; spring AOP 并不以一个 尽善静美的AOP实现 作为目标，它希望推出一个能与 spring IOC 框架 整合 的框架，使它们一起为企业级应用提供便捷的开发解决方案。 spring AOP 动态代理有两种实现形式: JDK 原生动态代理 和 CGLIB 动态代理。如果被代理的目标对象没有实现接口，CGLIB 动态代理 将被置为默认选择。 三. spring AOP 详解这里因为篇幅原因我只描述 spring 基于注解的 AOP 实现，spring 还支持基于 xml schema 配置的 AOP 实现，它们除了表现形式不同之外没什么其他区别。相比而言 注解形式 更清晰便捷。对 xml schema 配置形式感兴趣的小伙伴可以自己了解。 I. 使用 @AspectJ 注解声明切面 @AspectJ 是 Aspectj框架支持的注解，通过引入 AspectJ Library 依赖, spring 将支持 AspectJ 中相关注解的解析，但是spring不会使用 AspectJ 中的编译和织入功能。 引入 AspectJ Library 后， @AspectJ 注解将可以声明一个普通class为切面定义类。 maven 依赖引入样例如下: 123456789101112 &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt; &lt;version&gt;1.8.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.1&lt;/version&gt;&lt;/dependency&gt; 启用切面注解配置功能: spring 同时支持 XML schema 切面配置 和 注解形式 切面配置，若想启用注解方式，则需要在配置类(@Configuration 注释的类)上标注启用标签@EnableAspectJAutoProxy: 1234@Configuration@EnableAspectJAutoProxy//@EnableAspectJAutoProxy(proxyTargetClass = true) // 将代理方式选定为 CGLIB动态代理public class AppConfig &#123; &#125; 注意 @EnableAspectJAutoProxy 可以指定 proxyTargetClass 属性，它用来控制是否只用 CGLIB 动态代理(默认为false, 即由spring框架自动选择代理逻辑)。 声明切面: 只需要在定义的切面类上加上 @AspectJ 注解即可将其标注为切面定义类: 1234package org.xyz;import org.aspectj.lang.annotation.Aspect;@Aspectpublic class NotVeryUsefulAspect &#123; &#125; 注意需要保证该类能够被配置类扫描到。 II. pointcut 声明 pointcut(切点)用来定义 advice(切面逻辑) 和 joint point(连接点) 的匹配规则。在spring中，目前支持的连接点类型只有方法，因此可以认为 pointcut 只用来定义方法匹配规则就好了。 一个pointcut声明包含两个部分: pointcut 方法声明，该方法没有任何参数，返回值为void; pointcut 表达式, 使用 @Pointcut 注解定义; 将pointcut样例如下: 12￼ @Pointcut("execution(* transfer(..))")// the pointcut expression private void anyOldTransfer() &#123;&#125;// the pointcut signature spring 的 pointcut 表达式就是复用 AspectJ 的pointcut表达式。 III. spring 支持的 pointcut 表达式类型 spring 只是支持了部分的 AspectJ pointcut 表达式规则，接下来我们逐一讲解其所支持的表达式规则。 execution 切点 execution 切点是最常用的切点定义方式，其定义模式如下: 1execution(modifier-pattern? ret-type-pattern declaring-type-pattern?name-pattern(param-patterm) throw-pattern?) pattern 含义 是否必须定义 modifier-pattern 修饰符 否 ret-type-pattern 返回值类型定义 是 declaring-type-pattern 方法类定义 否 name-pattern 方法名称定义 是 param-patterm 参数列表定义 是 throw-pattern 异常类型定义 否 pattern 可以使用通配符定义: * 用来匹配所有模式，.用来表示类路径的分量符,..表示一个包及其子包下的任意类, (..)可以表示任意参数列表(表示包含零个或多个任意类型参数) execution pointcut 定义样例: 12345678910111213141516171819202122232425262728293031323334/** * 任意public方法为切入点 */@Pointcut("execution(public * *(..))")public void anyPublicOperation() &#123;&#125;/** * 任意set方法为切入点 */@Pointcut("execution(* set*(..)")public void anySetOperation() &#123;&#125;/** * me.service 包下任意类的方法 */@Pointcut("execution(* me.service.*(..)")public void anyServiceOperation() &#123;&#125;/** * me.service 包及其子包下任意类的方法 */@Pointcut("execution(* me.service..*(..)")public void anyServiceBaseOperation() &#123;&#125;/** * 任意参数列表包含两个参数,且第二个参数类型是String类型的方法 */@Pointcut("execution(* *(*, String)")public void anyStringParamInSecondPlaceOperation() &#123;&#125; 样例中注释说明详尽，可以看出 execution 类型的pointcut基本可以满足任意场景的方法规则匹配。其他pointcut类型可以看做 execution 的部分限定规则。 within 切点 within 切点只做了包和类型的限定: 123456/** * 任意 me.service 包及其子包下各个类型的方法 */@Pointcut("within(me.service..*)")public void withinOperation() &#123;&#125; args 切点: args 切点只做了参数列表的限定: 123456/** * 任意参数列表包含两个参数,且第二个参数类型是String类型的方法 */@Pointcut("args(*, String)")public void argsOperation() &#123;&#125; args 切点和 execution execution(* *(*, String) 切点还是不太相同的，execution 限定了目标方法的定义方式，而args则限定了目标方法在运行时是否传入 (*, String) 参数列表,是一种运行时限定。 this 切点: this 用来限定代理对象(proxy object)是否实现了某个接口: 123456/** * 当一个代理对象实现了 me.Service 接口时才进行代理逻辑切入 */ @Pointcut("this(me.Service)") public void thisOperation() &#123; &#125; target 切入: target 用来限定目标对象(target object)是否实现了某个接口: 123456/** * 当一个目标对象实现了 me.Service 接口时才进行代理逻辑切入 */ @Pointcut("target(me.Service)") public void targetOperation() &#123; &#125; 注意 this 切入 和 target 切入 类型的区别，this是对代理对象的限定规则，target是对目标对象的限定规则。需要了解的是 JDK 动态代理 在实现时，proxy对象实现了代理接口，而 CGLIB 动态代理 却并不一定。同时spring AOP 的 Introduction 功能将使代理对象继承新的接口，但目标对象（业务对象）却并未继承任何接口。 bean 切入: bean 用来限定对象的名称: 123456/** * 任意以Service为后缀的bean */ @Pointcut("bean(*Service)") public void beanOperation() &#123; &#125; @target 切入: 匹配任意目标对象标注了特定标签: 123456/** * 任意目标对象标注了Transaction注解的方法 */@Pointcut("@target(me.Transaction)")public void targetAnnoationOperation() &#123;&#125; @within 切入: 匹配任意拥有特定注解的类型: 123456/** * 任意标注了Transaction注解的类的方法 */ @Pointcut("@within(me.Transaction)") public void withinAnnotationOperation() &#123; &#125; @annotation 切入: 匹配任意标注了特定注解的方法: 123456/** * 任意标注了Transaction注解的方法 */ @Pointcut("@annotation(me.Transaction)") public void annotationMethodOperation() &#123; &#125; @args 切入: 匹配任意参数列表添加了特定注解注释的方法: 123456/** * 任意参数列表只有一个参数,且参数标注了Transaction注解的方法 */ @Pointcut("@args(me.Transaction)") public void argsAnnotationMethodOperation() &#123; &#125; 切点联立表达规则: 任意已经定义的切点都可以使用逻辑关联符号联立表达形成新的符合切点，可用的逻辑关联符号有 &amp;&amp;, ||, !. 联立表达见样例如: 1234567891011121314151617181920212223242526272829/** * spring 切面编程 */@Aspectpublic class AspectExample &#123; /** * 切入任意 public 方法 */ @Pointcut("execution(public * *(..))") private void anyPublicOperator() &#123; &#125; /** * 定义在 me.trading 包下的任意方法 */ @Pointcut("within(me.trading..*)") private void inTrading() &#123; &#125; /** * 组合切点表达式,切入任意 me.trading 包下的 public 方法 */ @Pointcut("anyPublicOperator()||inTrading()") private void publicTrading() &#123; &#125;&#125; 在企业级应用开发中往往需要定义服务级别的公用切点，保证切点统一管理与可复用性。 IV. Advice 声明Advice的类型如之前所述，Advice 定义了切面的切入逻辑，按照在切点吃的执行方式，可以分为以下五种类型: before advice: 只在切点之前执行切面，该方式无法控制原业务方法的调用方式(除了抛出异常终止调用之外); after returning: 在切点定义的方法正常结束之后执行切面; after throwing: 在切点因为异常退出时执行切面; after (finally): 无论切点以什么形式退出都会执行切面; around: 切面逻辑可以主动控制方法逻辑的调用，可以在方法前后插入任意逻辑。这种方式显然最为强大，因为它甚至可以阻断正常调用，返回自己特定的 return value; spring AOP 提供了完整的 Advice 类型，也许大家会觉得 around 用起来简直爽到爆了, 但是值得提醒的是权限越大责任也越大，随之而来的风险也越大了，因此尽量只选择足够功能的 Advice 类型才是王道呀。 @Before 通知声明: before 类型的 Advice 使用 @Before(pointcut expression) 来标注方法实现： 1234567import org.aspectj.lang.annotation.Aspect; import org.aspectj.lang.annotation.Before;@Aspectpublic class BeforeExample &#123;// @Before("com.xyz.myapp.SystemArchitecture.dataAccessOperation()") 通过切点引用声明切入切入点 @Before("execution(* com.xyz.myapp.dao.*.*(..))") // 通过切点表达式声明切入点 public void doAccessCheck() &#123; // ... &#125;&#125; @AfterReturning 通知声明: 见样例: 1234567import org.aspectj.lang.annotation.Aspect; import org.aspectj.lang.annotation.AfterReturning; @Aspect public class AfterReturningExample &#123; @AfterReturning("com.xyz.myapp.SystemArchitecture.dataAccessOperation()") public void doAccessCheck() &#123; // ... &#125; &#125; 可能我们希望访问方法返回的返回值，此时可以用 returnning 指定返回值参数名称: 12345678import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.AfterReturning;@Aspectpublic class AfterReturningExample &#123; @AfterReturning(pointcut="com.xyz.myapp.SystemArchitecture.dataAccessOperation()", returning="retVal")public void doAccessCheck(Object retVal) &#123; // ...&#125; &#125; @AfterThrowing 通知声明: 见样例: 123456import org.aspectj.lang.annotation.Aspect; import org.aspectj.lang.annotation.AfterThrowing;@Aspectpublic class AfterThrowingExample &#123; @AfterThrowing("com.xyz.myapp.SystemArchitecture.dataAccessOperation()")public void doRecoveryActions() &#123; // ...&#125; &#125; 通常可以定义指定异常类型的切点通知，且需要在执行逻辑中使用该异常对象(方法参数的异常类型可以为 Throwable) 12345678import org.aspectj.lang.annotation.Aspect; import org.aspectj.lang.annotation.AfterThrowing;@Aspectpublic class AfterThrowingExample &#123; @AfterThrowing( pointcut="com.xyz.myapp.SystemArchitecture.dataAccessOperation()", throwing="ex")public void doRecoveryActions(DataAccessException ex) &#123; // ...&#125; &#125; @After 通知声明: 见样例: 123456import org.aspectj.lang.annotation.Aspect; import org.aspectj.lang.annotation.After;@Aspectpublic class AfterFinallyExample &#123; @After("com.xyz.myapp.SystemArchitecture.dataAccessOperation()")public void doReleaseLock() &#123; // ...&#125; &#125; after 通知通常在方法结束后运行，因此不能从通知逻辑中抛出异常。该通知通常用于释放资源 @Arround 通知声明: 见样例: 123456789import org.aspectj.lang.annotation.Aspect; import org.aspectj.lang.annotation.Around; import org.aspectj.lang.ProceedingJoinPoint;@Aspectpublic class AroundExample &#123; @Around("com.xyz.myapp.SystemArchitecture.businessService()")public Object doBasicProfiling(ProceedingJoinPoint pjp) throws Throwable &#123; // start stopwatchObject retVal = pjp.proceed();// stop stopwatchreturn retVal; &#125;&#125; ProceedingJoinPoint 类型参数是around通知的必须参数， pip.proceed() 可以调用被代理方法执行。因此在around通知中，被代理方法是否执行完全取决于代理逻辑。 V. Advice 的参数管理JoinPoint 参数: 所有的 advice 方法都可以将第一个参数定义为org.aspectj.lang.JoinPoint类型（around advice方法中的第一个参数类型是ProceedingJoinPoint，它是JointPoint的子类），JoinPoint 参数封装了许多包含代理对象及目标对象信息获取的方法，对于代理逻辑十分有用。 其他传入参数: 在上面的 After Returnning Advice 和 After Throwing Advice 样例中，我们已经见到了一些外部参数传递方式。这里我们先使用 args pointcut 来演示如何传递外部参数: 12345@Pointcut("com.xyz.myapp.SystemArchitecture.dataAccessOperation() &amp;&amp; args(account,..)")private void accountDataAccessOperation(Account account) &#123;&#125;@Before("accountDataAccessOperation(account)")public void validateAccount(Account account) &#123; // ...&#125; 上面样例中 validateAccount 方法的参数列表定义了 Account account 参数 和 args pointcut 定义的参数名称一致（回顾一下 args pointcut 定义的是运行时传入参数类型，这里只定义了参数名称），spring AOP 框架将根据 方法参数的类型来确定 args 参数限定类型，同时从符合限定的方法调用中传递参数给 advice 方法。 其他pointcut类型的参数传递也是类似的: 1234@Retention(RetentionPolicy.RUNTIME) @Target(ElementType.METHOD)public @interface Auditable &#123; AuditCode value();&#125; 123@Before("com.xyz.lib.Pointcuts.anyPublicMethod() &amp;&amp; @annotation(auditable)")public void audit(Auditable auditable) &#123; AuditCode code = auditable.value(); // ...&#125; 泛型参数传递: spring AOP 在参数传递中也支持泛型处理，我们先定义泛型类型如下: 1234public interface Sample&lt;T&gt; &#123;void sampleGenericMethod(T param);void sampleGenericCollectionMethod(Collection&lt;T&gt; param);&#125; 接着定义切面逻辑，因为需要传递参数，我们需要限定参数的实际类型: 123@Before("execution(* ..Sample+.sampleGenericMethod(*)) &amp;&amp; args(param)")public void beforeSampleMethod(MyType param) &#123; // Advice implementation&#125; 显然这种切面定义是切实可行的，但是这种参数类型限定在泛型类中可能会遇到麻烦。比如我们定义如下切面: 123@Before("execution(* ..Sample+.sampleGenericCollectionMethod(*)) &amp;&amp; args(param)")public void beforeSampleMethod(Collection&lt;MyType&gt; param) &#123; // Advice implementation&#125; 此时为了校验运行时参数， Spring AOP 将校验参数容器中每个元素的类型，但这样做并不靠谱呀，我们并不知道容器中的null对象是否属于限定的类型 … 因此，spring AOP 使用了一种近似形式的传递形式: 将参数了类型指定为 Collection&lt;?&gt;, 将元素的类型校验交给咱们啦 ^ ^。 参数名称的定义: 也许有人已经发现，定义在Advice方法中的参数名称并不会在运行时获得的呀，那 spring AOP 是如何进行名称匹配的嘛😹！？ 不打紧，spring AOP 已经考虑到了，它提供了 三种策略 进行参数名匹配: 使用 argNames 参数列表: 直接上代码 12345 @Before(value="com.xyz.lib.Pointcuts.anyPublicMethod() &amp;&amp; target(bean) &amp;&amp; @annotation(auditable)", argNames="bean,auditable")public void audit(Object bean, Auditable auditable) &#123; AuditCode code = auditable.value();// ... use code and bean&#125; 看出端倪了吗？argNames 用一个逗号间隔的字符串定义了完整的参数名称列表(注意定义顺序哈~) 其实还有更强大的方式: 12345@Before(value="com.xyz.lib.Pointcuts.anyPublicMethod() &amp;&amp; target(bean) &amp;&amp; @annotation(auditable)", argNames="bean,auditable") public void audit(JoinPoint jp, Object bean, Auditable auditable) &#123; AuditCode code = auditable.value(); // ... use code, bean, and jp&#125; JoinPoint 参数作为 Advice 方法的第一个参数并没有在 argNames 中显示定义其名称。是的，默认是可以省略的👊。这让我们码农方便了不少呀 ^ ^。 获取类的debug信息: 写 argNames 总还是有些麻烦，当程序员未定义这个变量时，spring AOP 将尝试获取该类的 debug 信息。这些信息在编译后默认是不会保留的，需要显式在编译时驾驶 -g:vars 参数。增加这个参数会产生的结果: 代码因为没有 argNames 参数会略微易读一些; 编译后生成的class文件会略微大一些; 编译阶段原有对未使用本地变量的优化的功能将不再执行; 总而言之，编译时增加该标记并不会对项目有多少影响。 简单名称推断: 上面两步都没做，那就只能靠spring AOP 自己去猜（推断）啦 ~ spring的推断只是简单依据参数个数进行匹配，例如只定义了一个参数，那还用啥名称匹配呢（^ ^）？ 还不行那就抛错吧: 没错, 再不行spring AOP就会抛出 IllegalArgumentException 异常。 调用原方法时的参数传递: 这里无需多说，只需要按顺序创建参数列表数组并传递给 proceed() 方法即可: 123456@Around("execution(List&lt;Account&gt; find*(..)) &amp;&amp; " + "com.xyz.myapp.SystemArchitecture.inDataAccessLayer() &amp;&amp; " + "args(accountHolderNamePattern)")public Object preProcessQueryPattern(ProceedingJoinPoint pjp, String accountHolderNamePattern) throws Throwable &#123; String newPattern = preProcess(accountHolderNamePattern);return pjp.proceed(new Object[] &#123;newPattern&#125;); &#125; 多个Advice 在一个 join point 处的执行顺序: 如果在一个 join point 处有多个 advice，Spring AOP 采用和 AspectJ 类似的优先级来指定通知的执行顺序。目标函数调用前，优先级高的advice先执行，目标函数调用后，优先级高的advice后执行。 如果两个通知分别定义在各自的 Aspect 内，可以通过如下两种方式控制 Aspect 的施加顺序： Aspect 类添加注解指定顺序值：org.springframework.core.annotation.Order Aspect 类实现接口通过getOrder()方法指定顺序值：org.springframework.core.Ordered 顺序值是一个整数，数值越小代表的优先级越大 如果两个 advice 位于同一 aspect 内，且执行顺序有先后，通过 advice 的声明顺序是无法确定其执行顺序的，因为 advice 方法的声明顺序无法通过反射获取，只能采取如下变通方式，二选一： 将两个 advice 合并为一个 advice，那么执行顺序就可以通过代码控制了 将两个 advice 分别抽离到各自的 aspect 内，然后为 aspect 指定执行顺序 introduction 引入功能 Introduction 引入功能 将使被代理的对象拥有额外接口，使其无需继承便拥有特定接口的特定实现。Introduction 使用 @DeclareParents注解定义引入的接口和实现。下面贴出样例来分析引用过程: 123456789@Aspectpublic class UsageTracking &#123; @DeclareParents(value="com.xzy.myapp.service.*+", defaultImpl=DefaultUsageTracked.class) public static UsageTracked mixin; @Before("com.xyz.myapp.SystemArchitecture.businessService() &amp;&amp; this(usageTracked)") public void recordUsage(UsageTracked usageTracked) &#123; usageTracked.incrementUseCount();&#125; &#125; 上面样例中 UsageTracked 是一个接口, DefaultUsageTracked 是该接口的一个实现类。上面定义的@DeclareParents(value=&quot;com.xzy.myapp.service.*+&quot;, defaultImpl=DefaultUsageTracked.class)声明了com.xzy.myapp.service包下的所有类都将引入UsageTracked接口的功能，默认执行DefaultUsageTracked.class类的实现逻辑。 总结本次只是简单了解了 AOP 的基本概念以及其使用方式，可以说除了概念较丰富之外并无过多难度。后续将进一步梳理 spring AOP 的更多内容，包括 spring AOP API, spring AOP 实现原理, spring AOP 应用场景实践等。欢迎各位小伙伴多提意见 ^ ^。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CGLIB 动态代理初讲]]></title>
      <url>%2F2017%2F02%2F07%2FCGLIB-1%2F</url>
      <content type="text"><![CDATA[简述: CGLIB (Code Generation Library) 底层基于 ASM 字节码处理框架, 能够在运行时生成新的java字节码，因此在动态代理方面使用广泛。相对于 JDK 原生动态代理, 它无需依赖接口，能够对任意类生成代理对象。 一、CGLIB 实现动态代理的一般步骤 在 CGLIB 中存在一个关键类 Enhancer。众所周知，代理要对原有对象对外暴露功能进行托管和增强，对于一个业务对象，狭义上的对外契约可以认为是业务接口，但是广义而言，任意对象的 public 方法都可以认为是暴露于外部的契约。因此在 CGLIB 中，其代理类的创建可以依赖任意类(区别于 JDK 原生动态代理 的面向接口代理)。 CGLIB 动态代理实现的简单步骤如下: 123456Enhancer enhancer = new Enhancer(); // 创建增强器enhancer.setSuperclass(businessObject.getClass()); // 设置被代理类enhancer.setCallback(callBackLogic); // 设置代理逻辑Business businessProxy = (Business)enhancer.create(); // 创建代理对象 businessProxy.doBusiness(); // 业务调用 上面步骤中 callBackLogic 是代理逻辑调用器对象，定义了具体代理切入逻辑、方法调用方式等，为 CGLIB 中 Callback 接口的实例。CGLIB 中有许多不同的 CallBack 子接口，对应了各种不同功能的代理逻辑。 CallBack 子接口展示: 二、CGLIB 动态代理实现样例老话讲,唯有实战才是磨炼技能的唯一标准，接下来我们根据一些简单样例分析 CGLIB 的特性: 依赖配置 maven 依赖配置: 1234567&lt;!--cglib maven 依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;cglib&lt;/groupId&gt; &lt;artifactId&gt;cglib&lt;/artifactId&gt; &lt;version&gt;3.2.4&lt;/version&gt;&lt;/dependency&gt; FixedValue 代理逻辑调用器 功能介绍: FixedValue 增强器将为目标类(包含目标类的父类)的所有方法(准确而言应该是非static且非final的public方法)设置固定返回值。在代理对象调用任一方法时,预设置的返回值将被强制转换成对应方法定义的返回值类型。因此，当类型无法强制转换时会抛出 ClassCastException 异常; 样例代码展示: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import net.sf.cglib.proxy.Enhancer;import net.sf.cglib.proxy.FixedValue;/** * FixedValue 测试 */public class CglibFixedValue &#123; public static void testFixedValue() &#123; Business business = new Business(); /** * 初始化增强器 * */ Enhancer enhancer = new Enhancer(); // 创建增强器 enhancer.setSuperclass(business.getClass()); enhancer.setCallback((FixedValue) () -&gt; "do business by proxy"); /** * 创建代理对象 * */ Business businessPrxy = (Business) enhancer.create(); System.out.println(business.doBusiness()); System.out.println(businessPrxy.doBusiness()); // System.out.println(businessPrxy.hashCode()); // err: ClassCastException /** * 创建代理增强类的类型 * */ Class cls = enhancer.createClass(); System.out.println(cls.getSuperclass().equals(business.getClass())); // Date datePrxy = (Date) enhancer.create(); // err: ClassCastException &#125; public static void main(String... args) &#123; testFixedValue(); &#125; /** 业务类定义 */ private static class Business &#123; public Business() &#123; &#125; // 静态方法 public static String staticDoBusiness() &#123; return "staticDoBusiness"; &#125; public String doBusiness() &#123; return "doBusiness"; &#125; final public String finalDoBusiness() &#123; return "finalDoBusiness"; &#125; private String privateDoBusiness()&#123; return "privateDoBusiness"; &#125; protected String protectedDoBusiness()&#123; return "protectedDoBusiness"; &#125; &#125;&#125; 运行结果如下: 1234非代理对象业务调用: doBusiness业务方法代理调用: do business by proxy父类方法代理调用: do business by proxy代理增强类是否是业务类的子类: true 正如开始描述，FixedValue 将会设置目标类及其父类中的方法返回固定值。代码样例中注释部分调用将产生类型转换异常。需要注意的是Business 类中定义了静态方法(staticDoBusiness),final方法(finalDoBusiness),private方法(privateDoBusiness)和protected方法(protectedDoBusiness),我在debug模式使用控制台监控器调用结果如下: 显然这些方法都未被代理重写。这是因为 CGLIB 只会对 非final且非static的public方法 进行代理逻辑重写。 InvocationHandler 代理逻辑调用器 CGLIB 和 JDK原生动态代理 一样也支持 InvocationHandler 形式的动态代理, 其实现样例如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import net.sf.cglib.proxy.Enhancer;import net.sf.cglib.proxy.InvocationHandler;import java.lang.reflect.Method;/** * invocationHandler 代理逻辑调用器 */public class CglibInvocationHandler &#123; public static void main(String... args) &#123; Business business = new Business(); Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(business.getClass()); enhancer.setCallback(new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; Object rt = null; System.out.println("do before business"); if (method.getReturnType().equals(String.class)) &#123; rt = method.invoke(business, args); &#125; else &#123; rt = "未知调用"; /** * 不能直接调用proxy对象的method方法, 将会产生死循环 * */ // method.invoke(proxy, args); &#125; System.out.println("do after business"); return rt; &#125; &#125;); Business businessProxy = (Business) enhancer.create(); businessProxy.doBusiness(); &#125; /** * 业务类 */ private static class Business &#123; public Business() &#123; &#125; public String doBusiness() &#123; System.out.println("do business"); return "do business"; &#125; &#125;&#125; 从样例代码中可以看出，和 JDK原生动态代理 一样，代理逻辑都是覆写 InvocationHandler 接口中的 invoke 方法实现的。需要注意的是，对原始方法的调用必须显式引入具体被代理的对象(业务对象)，对代理对象proxy直接使用method.invoke(proxy, args)进行方法调用将产生无限死循环!回顾一下JDK原生动态代理，应该也存在类似的问题。因此 InvocationHandler 在实际应用场景下并不常用，接下来介绍的 MethodInterceptor 将会解决这个问题。 MethodInterceptor 代理逻辑调用器 MethodInterceptor 代理逻辑调用器是最常用的代理方式，其调用样例如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import net.sf.cglib.proxy.Enhancer;import net.sf.cglib.proxy.MethodInterceptor;import net.sf.cglib.proxy.MethodProxy;import java.lang.reflect.Method;/** * MethodInterceptor 代理逻辑调用器 */public class CglibMethodInterceptor &#123; public static void main(String... args) &#123; Business business = new Business(); Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(business.getClass()); enhancer.setCallback(new MethodInterceptor() &#123; @Override public Object intercept( Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123; Object rt; System.out.println("===\ndo before business"); if (method.getReturnType().equals(String.class)) &#123; rt = proxy.invokeSuper(obj, args); // 调用原始方法(被代理业务对象的方法) &#125; else &#123; rt = "未知调用"; System.out.println(rt); &#125; System.out.println("do after business"); return rt; &#125; &#125;); Business businessProxy = (Business) enhancer.create(); System.out.println(businessProxy.doBusiness()); businessProxy.doBusiness("do business"); &#125; /** * 业务类 */ private static class Business &#123; public Business() &#123; &#125; public String doBusiness() &#123; System.out.println("do business"); return "business return value"; &#125; public void doBusiness(String arg) &#123; System.out.println(arg); &#125; &#125;&#125; 和 InvocationHandler 对比而言，其代理方法 intercept 的参数列表中多出一个 MethodProxy proxy 参数。proxy 参数是被代理类托管方法的封装。样例中 proxy.invokeSuper(obj, args); 这句代码就实现了对原始方法的调用，特别指出的是该调用并不依赖原始对象的引用（其中的obj对象是代理对象），也不会像 InvocationHandler 一样造成 invoke 死循环风险。 上面样例执行结果如下: 123456789===do before businessdo businessdo after businessbusiness return value===do before business未知调用do after business LazyLoader 代理逻辑调用器 延迟加载将定义一个代理创建过程，返回被代理类型的一个对象实例。延迟加载样例代码如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import net.sf.cglib.proxy.Enhancer;import net.sf.cglib.proxy.LazyLoader;/** * LazyLoader 代理逻辑调用器 */public class CglibLazyLoader &#123; public static void main(String... args) &#123; Business business = lazyLoadString("hello world"); System.out.println("首次调用对象"); System.out.println(business.getProperty()); System.out.println("再次调用对象"); System.out.println(business.getProperty()); &#125; /** * 延迟加载方法 */ public static Business lazyLoadString(String msg) &#123; Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(Business.class); enhancer.setCallback(new LazyLoader() &#123; @Override public Object loadObject() throws Exception &#123; System.out.println("延迟加载调用"); return new Business(msg); &#125; &#125;); Business business = (Business) enhancer.create(); return business; &#125; public static class Business &#123; private String property; public Business() &#123; &#125; public Business(String property) &#123; this.property = property; &#125; public String getProperty() &#123; return property; &#125; public void setProperty(String property) &#123; this.property = property; &#125; &#125;&#125; 代理逻辑方法的签名是不是很熟悉？没错，这个 public Object loadObject() throws Exception 和 FixedValue 中的方法签名是一样的，但是他们的功能却截然不同。在 LazyLoader 中，他负责创建并返回一个业务对象的实例。该样例的运行结果如下: 12345首次调用对象延迟加载调用hello world再次调用对象hello world 看来 Business business = lazyLoadString(&quot;hello world&quot;); 并没有正真创建Business实例, 而是在代理对象第一次进行方法调用时才正真触发实例创建操作。可想而知 LazyLoader 的功能了吧 ^ ^。 Dispatcher 代理逻辑调用器 Dispatcher 接口用来定义一个可分发对象，它需要使用 CallbackFilter 实现对象路由策略: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import net.sf.cglib.proxy.Callback;import net.sf.cglib.proxy.Dispatcher;import net.sf.cglib.proxy.Enhancer;/** * Dispatcher 代理逻辑 */public class CglibDispatcher &#123; public static void main(String... args) &#123; Object[] business = new Object[]&#123;(Eat) () -&gt; "eat", (Drink) () -&gt; "drink"&#125;; Object person = createPerson(business); System.out.println(((Eat) person).eat()); System.out.println(((Drink) person).drink()); business[0] = (Eat) () -&gt; "Eat"; System.out.println(((Eat) person).eat()); &#125; /** * 创建代理对象 */ public static Object createPerson(Object[] business) &#123; Enhancer enhancer = new Enhancer(); enhancer.setInterfaces(new Class[]&#123;Eat.class, Drink.class&#125;); // 设置代理接口 enhancer.setCallbackFilter( method -&gt; method.getName().equals("eat") ? 0 : 1); // 设置分发路由规则 enhancer.setCallbacks(new Callback[]&#123; (Dispatcher) () -&gt; &#123; System.out.println("set callback0"); return business[0]; &#125;, (Dispatcher) () -&gt; &#123; System.out.println("set callback1"); return business[1]; &#125;&#125;); // 设置调度对象 return enhancer.create(); &#125; /** * 业务类定义 * * 这里定义了两个业务类型 */ interface Eat &#123; String eat(); &#125; interface Drink &#123; String drink(); &#125;&#125; 让我们先看一下输出: 123456set callback0eatset callback1drinkset callback0Eat 根据我们在 enhancer.setCallbackFilter 里面定义的代理路由逻辑，被调的方法名称决定了路由对象。根据输出结果不难推断：当代理对象方法调用时，对应目标对象的装载方法也将被执行。因此可以保证目标对象更新时，装载对象无需更新。 ProxyRefDispatcher 代理逻辑调用器 ProxyRefDispatcher 也是一个代理分发器，其实现逻辑和特性基本与 Dispatcher 一致。唯一的区别在于其装载方法中传递了一个当前代理对象的引用 proxy: 12345678910111213141516package net.sf.cglib.proxy;/** * Dispatching &#123;@link Enhancer&#125; callback. This is the same as the * &#123;@link Dispatcher&#125; except for the addition of an argument * which references the proxy object. */public interface ProxyRefDispatcher extends Callback &#123; /** * Return the object which the original method invocation should * be dispatched. This method is called for &lt;b&gt;every&lt;/b&gt; method invocation. * @param proxy a reference to the proxy (generated) object * @return an object that can invoke the method */ Object loadObject(Object proxy) throws Exception;&#125; 构建和 Dispatcher 相似的样例代码如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import net.sf.cglib.proxy.Callback;import net.sf.cglib.proxy.Enhancer;import net.sf.cglib.proxy.ProxyRefDispatcher;/** * Dispatcher 代理逻辑 */public class CglibDispatcher &#123; public static void main(String... args) &#123; Object[] business = new Object[]&#123;(Eat) () -&gt; "eat", (Drink) () -&gt; "drink"&#125;; Object person = createPerson(business); System.out.println(((Eat) person).eat()); System.out.println(((Drink) person).drink()); business[0] = (Eat) () -&gt; "Eat"; System.out.println(((Eat) person).eat()); &#125; /** * 创建代理对象 */ public static Object createPerson(Object[] business) &#123; Enhancer enhancer = new Enhancer(); enhancer.setInterfaces(new Class[]&#123;Eat.class, Drink.class&#125;); // 设置代理接口 enhancer.setCallbackFilter( method -&gt; method.getName().equals("eat") ? 0 : 1); // 设置分发路由规则 enhancer.setCallbacks(new Callback[]&#123; (ProxyRefDispatcher) (p) -&gt; &#123; System.out.println("set callback0"); return business[0]; &#125;, (ProxyRefDispatcher) (p) -&gt; &#123; System.out.println("set callback1"); return business[1]; &#125;&#125;); // 设置调度对象 return enhancer.create(); &#125; /** * 业务类定义 * * 这里定义了两个业务类型 */ interface Eat &#123; String eat(); &#125; interface Drink &#123; String drink(); &#125;&#125; 其运行结果与 Dispatcher 样例一致: 123456set callback0eatset callback1drinkset callback0Eat 由此可见它们的区别仅在于目标对象装载上，ProxyRefDispatcher 可以在装载时更方便地使用代理对象的信息。 NoOp 代理逻辑调用器 NoOp 代理逻辑调用器正如其名字所定义，若一个方法使用该调用器，代理对象将直接调用被代理对象的方法，不进行任何逻辑切入。可能有人会疑惑什么场景会使用一个不切入代理逻辑的代理调用？确实如此，NoOp 一般不会单独使用，它往往配合其他调用器实现复杂的方法代理功能，请见如下样例: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import net.sf.cglib.proxy.CallbackHelper;import net.sf.cglib.proxy.Enhancer;import net.sf.cglib.proxy.MethodInterceptor;import net.sf.cglib.proxy.NoOp;import java.lang.reflect.Method;/** * NoOp 代理逻辑调用器 */public class CglibNoOp &#123; public static void main(String... args) &#123; Business business = createProxy(Business.class); System.out.println("开始调用非业务方法"); business.sayHello(); System.out.println("开始调用业务方法"); business.doBusiness(); &#125; public static Business createProxy(Class proxyCls) &#123; CallbackHelper callbackHelper = new CallbackHelper(proxyCls, new Class[0]) &#123; @Override protected Object getCallback(Method method) &#123; /** * 根据方法名称判断业务方法 * * 1. 对于业务方法切入代理逻辑 * * 2. 对于其他方法, 不进行代理操作*/ if (method.getName().contains("Business")) &#123; return (MethodInterceptor) (obj, method1, args, proxy) -&gt; &#123; System.out.println("do proxy logical"); return proxy.invokeSuper(obj, args); &#125;; &#125; else &#123; return NoOp.INSTANCE; &#125; &#125; &#125;; Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(proxyCls); enhancer.setCallbackFilter(callbackHelper); enhancer.setCallbacks(callbackHelper.getCallbacks()); return (Business) enhancer.create(); &#125; private static class Business &#123; public Business() &#123; &#125; public void sayHello() &#123; System.out.println("hello world"); &#125; public void doBusiness() &#123; System.out.println("do business"); &#125; &#125;&#125; 该样例输出结果如下: 12345开始调用非业务方法hello world开始调用业务方法do proxy logicaldo business 哈哈~ 看明白了吗？这里新引入了一个 CallBackHelper 类型对象，它的 getCallback() 方法将根据被调方法信息选择合适的 CallBack 实例。是的，对于一个类来说，并不是所有的方法都需要存在代理逻辑，如Object.clone()方法，此时使用 NoOp.INSTANCE 对象就再合适不过了 ^ ^。 友情提示 样例中大量使用了非静态匿名类的声明方式，该方式会在内部类对象中隐式生成一个外部类对象的引用。而内部类对象往往难以直接引用，当内部类对象不能释放时，外部类对象也将无法释放，容易引发 java内存写漏。样例中的使用方式完全在于缩减代码量考虑，生产环境中可使用静态内部类代替。 三、CGLIB 动态代理特点归纳和总结简单列一下 CGLIB 代理的特点作为参考吧: CGLIB 的代理实现需要依赖第三方库; CGLIB 支持类级别的代理(相对于 JDK 动态代理 更为方便); CGLIB 只支持对 非static且非final的public方法 进行代理; CGLIB 支持多种代理逻辑调用器，可以实现丰富的代理，分发功能（后续会做更详细介绍）; 个人认为 CGLIB 代理实现上更直观简洁; 不难发现 CGLIB 的 代理逻辑 和 代理装配逻辑 也相互隔离，而装配逻辑可能在运行时才确定。因此 CGLIB 和 JDK原生动态代理 一样也是运行时实现代理生成的。但相较而言，使用 CGLIB 实现动态代理会更方便，更安全。 想要更深度了解 CGLIB 的小伙伴可以阅读官方tutorial,必须让你受益无穷。 ^ ^]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JDK 动态代理机制]]></title>
      <url>%2F2017%2F02%2F06%2FJDK-proxy%2F</url>
      <content type="text"><![CDATA[简述JDK 动态代理是一种基于反射的运行时逻辑切入。实现简单，但只作用于接口级别。以下示例将一步步演示其实现过程并分析其实现特点及应用场景。 一、java 动态代理实现简述- UML 类图描述: 类图分析: 从类图关系可以看出，代理逻辑(ProxyHandler)和业务逻辑(BusinessImpl)在定义时是相互独立的。 代理对象是由Proxy.newProxyInstance() 方法生成, 该方法强依赖于 代理逻辑实例(InvocationHandler实例对象) 和 被代理业务接口(IBusiness)。 类图总结: 通过分析我们可以得出代理对象的创建必须依赖具体代理逻辑的定义和被代理接口的定义。创建代理的过程可以分为如下几步: 定义并明确需要被代理的业务接口; 实现 InvocationHandler 接口，创建代理逻辑实例类; 通过 Proxy.newProxyInstance() 方法创建具体代理对象 需要注意的是 InvocationHandler 实例类也依赖具体的业务对象，因为在代理进行方法调用时必须明确自己代理的目标对象是什么。 二、JDK 动态代理样例实现- 定义业务接口和业务实现类业务接口和实现类完全根据业务需求进行定义和实现，这里只做简单 demo 演示，故只是实现了一个简介的 doBusiness 方法: 业务接口: 123456789101112131415/** * 业务接口 */public interface IBusiness &#123; /** * 业务方法 * * @param business 业务参数 * @return 执行成功返回 true, 失败返回 false * @throws IllegalArgumentException 参数异常时抛出 */ public Boolean doBusiness(String business) throws IllegalArgumentException;&#125; 业务实例类: 1234567891011121314151617181920212223import org.apache.commons.lang3.Validate;/** * 业务细节实现类 */public class BusinessImpl implements IBusiness &#123; /** * 业务方法 * * @param business 业务参数 * @return 执行成功返回 true, 失败返回 false * @throws IllegalArgumentException 参数异常时抛出 */ public Boolean doBusiness( String business) throws IllegalArgumentException &#123; Validate.notBlank(business); // 参数校验 System.out.println("Do business: " + business); // 业务逻辑 return true; // 业务返回 &#125;&#125; - 代理逻辑定义(InvocationHandler实现)代理逻辑区别于普通业务逻辑，他可以是基于框架功能的抽象，也可以是更泛化的业务逻辑抽象，但是他的功能应该是明确的: 代理的存在一方面让具体业务实例在进行业务操作时更加纯粹(干净), 另外也使抽象逻辑的管理更加统一。 常见的代理逻辑如: 调用日志记录，监控打点，会话管理，资源回收 等。这里我们只做简单的打印实现（主要是方便观察效果 ^^）: 12345678910111213141516171819202122232425262728293031323334353637383940414243import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;/** * 代理操作类 * * 其作用是定义具体的代理逻辑 */public class ProxyHandler implements InvocationHandler &#123; private Object businessObject; /** * 该案例通过构造函数设置被代理对象(可选) */ public ProxyHandler(Object businessObject) &#123; this.businessObject = businessObject; &#125; /** * 具体代理逻辑切入实现 * * 可以实现的功能: * * 1. 逻辑织入(调用前后增加非业务逻辑) * * 2. 控制调用姿势(根据上下文方法控制调用方式) * * 3. 返回值和异常控制 * * @param proxy 代理对象 * @param method 被调用的业务接口方法 * @param args 被调用业务接口方法的参数 */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println("Do something before method"); Object result = businessObject == null ? null : method.invoke(businessObject, args); System.out.println("Do something after method"); return result; &#125;&#125; 可以看出代理逻辑的实现还是比较简单清晰的，这里做了被调方法在调用前后的操作(打印)，方法调用时的判断操作以及返回值的传递操作。不难发现代理对调用的控制相当全面，他直接决定了方法是否真正调用。 需要注意的是: 因为基于反射的method方法调用必须依赖具体执行对象作为参数，所以调用逻辑在实现时也需要依赖具体的业务实例。（本例中在构造函数中引入实例引用，当然也可以以set方法的的形式传入，这样还可以达到意想不到的效果哦 ^ ^ ) - 代理对象的创建和使用(Proxy.newProxyInstance())豪爽的我直接上代码: 123456789101112131415161718192021222324import java.lang.reflect.Proxy;/** * JDK 动态代场景理测试 */public class ProxyTest &#123; public static void main(String... args) &#123; BusinessImpl business = new BusinessImpl(); // 业务对象实例 ProxyHandler proxyHandler = new ProxyHandler(business); // 代理逻辑执行器对象 /**创建代理对象*/ IBusiness businessProxy = (IBusiness) Proxy.newProxyInstance( business.getClass().getClassLoader(), new Class[]&#123;IBusiness.class&#125;, proxyHandler); businessProxy.doBusiness("business"); // 处理业务 &#125;&#125; 寥寥几行, 不要太简单！！代理对象的创建只需三个参数: 被代理对象的类加载器; 被代理的接口列表; 刚刚定义的代理逻辑实例对象; 接下来让我们看看执行效果: 123Do something before methodDo business: businessDo something after method 哈哈~ 代理逻辑已经完美执行! 三、JDK 动态代理特性分析上面已经说过，代理的存在一方面让具体业务实例在进行业务操作时更加纯粹(干净), 另外也使抽象逻辑的管理更加统一。需要指出的是 JDK 动态代理 只是众多代理实现方式中的一种，如在spring框架中，其AOP实现就综合了 JDK 动态代理 和 CGLIB 代理 。接下来让我们总结一下 JDK 动态代理 的特点: JDK 原生支持，无需依赖第三方库； JDK 动态代理 实质上为运行时通过代理对象间接调用目标对象方法达到逻辑切入目的（并不修改原有业务逻辑） 依赖业务接口。代理对象在生成时强依赖于被代理的业务接口，因此在使用过程中可能会增加不必要的接口定义（不支持方法粒度代理）。 代理逻辑实现方便，但也过于简陋。对于被代理对象，他的所有方法在调用时都会执行代理逻辑类中的invoke方法，这也说明在唯一的一个invoke方法中必须cover目标对象中所有方法的执行逻辑。很显然，当接口中存在代理逻辑不一致的方法时，这种方式很容易造成不必要的耦合，不便于代理逻辑开发维护（代理逻辑定义时容易耦合）。 四、总结 代理的应用在框架类型的项目开发中是很常见的，其重要性不言而喻。本篇简单介绍了原生的JDK 动态代理，其实现简单，逻辑清晰。可以看出在普通面向接口，切入逻辑简单且统一的代理实现上，JDK 动态代理是一个不错的选择，但是面对更细致的代理场景，如跨接口的方法级别代理需求，JDK 动态代理便显得余力不足了。后面的博文中向大家介绍一个方法级别的代理库—-CGLIB,它也是 spring AOP 代理实现中的重要一员。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[spring AOP APIs 简述]]></title>
      <url>%2F2017%2F02%2F04%2Fspring-AOP-APIs%2F</url>
      <content type="text"><![CDATA[1. Pointcut API1.1 接口定义: spring pointcut 用于将 advices 指向特定的类和方法。其具体定义如下: 12345678910111213141516171819202122232425262728293031323334353637package org.springframework.aop;/** * Core Spring pointcut abstraction. * * &lt;p&gt;A pointcut is composed of a &#123;@link ClassFilter&#125; and a &#123;@link MethodMatcher&#125;. * Both these basic terms and a Pointcut itself can be combined to build up combinations * (e.g. through &#123;@link org.springframework.aop.support.ComposablePointcut&#125;). * * @author Rod Johnson * @see ClassFilter * @see MethodMatcher * @see org.springframework.aop.support.Pointcuts * @see org.springframework.aop.support.ClassFilters * @see org.springframework.aop.support.MethodMatchers */public interface Pointcut &#123; /** * Return the ClassFilter for this pointcut. * @return the ClassFilter (never &#123;@code null&#125;) */ ClassFilter getClassFilter(); /** * Return the MethodMatcher for this pointcut. * @return the MethodMatcher (never &#123;@code null&#125;) */ MethodMatcher getMethodMatcher(); /** * Canonical Pointcut instance that always matches. */ Pointcut TRUE = TruePointcut.INSTANCE;&#125; 可以看出 pointcut 接口分成 `类型匹配` 和 `方法匹配` 两个部分, 它们共同实现了切点的识别; ClassFilter 接口: ClassFilter 用来指定需要切入的目标类型。其接口定义如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445 /* * Copyright 2002-2007 the original author or authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.springframework.aop;/** * Filter that restricts matching of a pointcut or introduction to * a given set of target classes. * * &lt;p&gt;Can be used as part of a &#123;@link Pointcut&#125; or for the entire * targeting of an &#123;@link IntroductionAdvisor&#125;. * * @author Rod Johnson * @see Pointcut * @see MethodMatcher */public interface ClassFilter &#123; /** * Should the pointcut apply to the given interface or target class? * @param clazz the candidate target class * @return whether the advice should apply to the given target class */ boolean matches(Class&lt;?&gt; clazz); /** * Canonical instance of a ClassFilter that matches all classes. */ ClassFilter TRUE = TrueClassFilter.INSTANCE;&#125; 如果 matches 方法返回 `true` 则对应的类将被选中为通知类型; MethodMatcher 接口: MethodMatcher 接口是一个更为重要的接口, 其具体实现如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697 /* * Copyright 2002-2012 the original author or authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.springframework.aop;import java.lang.reflect.Method;/** * Part of a &#123;@link Pointcut&#125;: Checks whether the target method is eligible for advice. * * &lt;p&gt;A MethodMatcher may be evaluated &lt;b&gt;statically&lt;/b&gt; or at &lt;b&gt;runtime&lt;/b&gt; (dynamically). * Static matching involves method and (possibly) method attributes. Dynamic matching * also makes arguments for a particular call available, and any effects of running * previous advice applying to the joinpoint. * * &lt;p&gt;If an implementation returns &#123;@code false&#125; from its &#123;@link #isRuntime()&#125; * method, evaluation can be performed statically, and the result will be the same * for all invocations of this method, whatever their arguments. This means that * if the &#123;@link #isRuntime()&#125; method returns &#123;@code false&#125;, the 3-arg * &#123;@link #matches(java.lang.reflect.Method, Class, Object[])&#125; method will never be invoked. * * &lt;p&gt;If an implementation returns &#123;@code true&#125; from its 2-arg * &#123;@link #matches(java.lang.reflect.Method, Class)&#125; method and its &#123;@link #isRuntime()&#125; method * returns &#123;@code true&#125;, the 3-arg &#123;@link #matches(java.lang.reflect.Method, Class, Object[])&#125; * method will be invoked &lt;i&gt;immediately before each potential execution of the related advice&lt;/i&gt;, * to decide whether the advice should run. All previous advice, such as earlier interceptors * in an interceptor chain, will have run, so any state changes they have produced in * parameters or ThreadLocal state will be available at the time of evaluation. * * @author Rod Johnson * @since 11.11.2003 * @see Pointcut * @see ClassFilter */public interface MethodMatcher &#123; /** * Perform static checking whether the given method matches. If this * returns &#123;@code false&#125; or if the &#123;@link #isRuntime()&#125; method * returns &#123;@code false&#125;, no runtime check (i.e. no. * &#123;@link #matches(java.lang.reflect.Method, Class, Object[])&#125; call) will be made. * @param method the candidate method * @param targetClass the target class (may be &#123;@code null&#125;, in which case * the candidate class must be taken to be the method's declaring class) * @return whether or not this method matches statically */ boolean matches(Method method, Class&lt;?&gt; targetClass); /** * Is this MethodMatcher dynamic, that is, must a final call be made on the * &#123;@link #matches(java.lang.reflect.Method, Class, Object[])&#125; method at * runtime even if the 2-arg matches method returns &#123;@code true&#125;? * &lt;p&gt;Can be invoked when an AOP proxy is created, and need not be invoked * again before each method invocation, * @return whether or not a runtime match via the 3-arg * &#123;@link #matches(java.lang.reflect.Method, Class, Object[])&#125; method * is required if static matching passed */ boolean isRuntime(); /** * Check whether there a runtime (dynamic) match for this method, * which must have matched statically. * &lt;p&gt;This method is invoked only if the 2-arg matches method returns * &#123;@code true&#125; for the given method and target class, and if the * &#123;@link #isRuntime()&#125; method returns &#123;@code true&#125;. Invoked * immediately before potential running of the advice, after any * advice earlier in the advice chain has run. * @param method the candidate method * @param targetClass the target class (may be &#123;@code null&#125;, in which case * the candidate class must be taken to be the method's declaring class) * @param args arguments to the method * @return whether there's a runtime match * @see MethodMatcher#matches(Method, Class) */ boolean matches(Method method, Class&lt;?&gt; targetClass, Object[] args); /** * Canonical instance that matches all methods. */ MethodMatcher TRUE = TrueMethodMatcher.INSTANCE;&#125; 当创建 proxy 对象时， `matches(Method method, Class&lt;?&gt; targetClass);`方法将被调用，该方法用于判断当前类的方法是否为切入点， 这个方法不会在目标对象被调用时执行。当 该方法返回true 且 isRuntime()方法返回 true时，每次调用目标对象的该方法都会触发 matches(Method method, Class&lt;?&gt; targetClass, Object[] args) 方法的调用， 此时会判断参数信息是否符合切入点匹配规则。大部分 MethodMatcher 都是静态的，这意味着 isRuntime()方法都是返回false,这样的Matcher将不会在目标对象调用时检测方法是否匹配切入规则。 1.2 对Pointcut的操作: spring 支持对 Pointcut 进行交并补操作: 交集操作意味着一个方法必须被所有的 pointcut 匹配通过; 并集操作意味着一个方法只需被任意一个 pointcut 匹配通过; 1.3 方便的 Pointcut 现有类实现: spring 提供了一系列Pointcut实例类,一些开箱即用，一些需要根据特定的应用场景集成实现特定的实例类。 静态 pointcut: 静态 pointcut 不基于方法调用时传入参数作为切点判断依据。它们只在 代理对象初始化时对类方法进行切入评估，因此更高效。以下是一些静态 pointcut 的实例类; 动态 pointcut: 相对于静态pointcut, 动态pointcut基于调用时传入的参数或其他运行时信息(如堆栈信息)评估方法切入。因此动态 pointcut 将在每次方法调用时进行评估，其消耗型相对较高; 2. Advice API2.1 advice 的生命周期:advice 可以分成 per-class 和 per-instance 两种。 per-class Advice 生命周期: 这种类型的Advice是无状态的，他只基于方法和参数实现通知逻辑，因此它可以被多个被通知对象共享。 per-instance Advice 生命周期: 这种类型的 Advice 通过特定的状态信息实现一些高级功能，因此其生命周期和具体的被代理实例对象相对应。 2.2 spring 中的 Advice:spring 提供了一系列开箱即用的 Advice 类型: interception around advice: 1234567public class DebugInterceptor implements MethodInterceptor &#123; public Object invoke( MethodInvocation invocation) throws Throwable &#123; System.out.println("Before: invocation=[" + invocation + "]"); Object rval = invocation.proceed(); System.out.println("Invocation returned"); return rval; &#125; &#125; Before advice 1234567891011public class CountingBeforeAdvice implements MethodBeforeAdvice &#123; private int count; public void before(Method m, Object[] args, Object target) throws Throwable &#123; ++count; &#125; public int getCount() &#123; return count; &#125; &#125; Throws advice 123456789101112public static class CombinedThrowsAdvice implements ThrowsAdvice &#123; public void afterThrowing( RemoteException ex) throws Throwable &#123; // Do something with remote exception &#125; public void afterThrowing( Method m, Object[] args, Object target, ServletException ex&#123; // Do something with all arguments &#125;&#125; After Returning advice 12345678910111213 public class CountingAfterReturningAdvice implements AfterReturningAdvice &#123; private int count; public void afterReturning( Object returnValue, Method m, Object[] args, Object target) throws Throwable &#123; ++count; &#125; public int getCount() &#123; return count; &#125;&#125; Introduction advice 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * 引入接口定义 */public interface Lockable &#123; void lock(); void unlock(); boolean locked(); &#125;/** * IntroductionIntecptor 定义 * IntroductionIntecptor 需要实现被引入的接口 * invoke 方法定义了拦截逻辑（覆写可选） */ public class LockMixin extends DelegatingIntroductionInterceptor implements Lockable &#123; private boolean locked; public void lock() &#123; this.locked = true; &#125; public void unlock() &#123; this.locked = false; &#125; public boolean locked() &#123; return this.locked; &#125; public Object invoke(MethodInvocation invocation) throws Throwable &#123; if (locked() &amp;&amp; invocation.getMethod().getName().indexOf("set") == 0) &#123; throw new LockedException(); &#125; return super.invoke(invocation); &#125; &#125;/** * IntroductionAdvisor 定义 * IntroductionAdvisor 定义了 引入接口 和 默认IntroductionIntecptor实例类 */public class LockMixinAdvisor extends DefaultIntroductionAdvisor &#123; public LockMixinAdvisor() &#123; super(new LockMixin(), Lockable.class); &#125;&#125; 3. Advisor APIspring 中，advisor 是包含了 advice 和 pointcut 的切面组合。除了特殊的 Introduction advice（引入通知），任何advisor可以使用任何advice。DefaultPointcutAdvisor 是使用最频繁的 advisor。]]></content>
    </entry>

    
  
  
</search>
