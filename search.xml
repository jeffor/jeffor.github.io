<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Hexo + NexT 博客搭建]]></title>
      <url>%2F2017%2F02%2F06%2Fpersonal-blog-creation%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[spring AOP APIs]]></title>
      <url>%2F2017%2F02%2F04%2Fspring-AOP-APIs%2F</url>
      <content type="text"><![CDATA[1. Pointcut API1.1 接口定义: spring pointcut 用于将 advices 指向特定的类和方法。其具体定义如下: 12345678910111213141516171819202122232425262728293031323334353637package org.springframework.aop;/** * Core Spring pointcut abstraction. * * &lt;p&gt;A pointcut is composed of a &#123;@link ClassFilter&#125; and a &#123;@link MethodMatcher&#125;. * Both these basic terms and a Pointcut itself can be combined to build up combinations * (e.g. through &#123;@link org.springframework.aop.support.ComposablePointcut&#125;). * * @author Rod Johnson * @see ClassFilter * @see MethodMatcher * @see org.springframework.aop.support.Pointcuts * @see org.springframework.aop.support.ClassFilters * @see org.springframework.aop.support.MethodMatchers */public interface Pointcut &#123; /** * Return the ClassFilter for this pointcut. * @return the ClassFilter (never &#123;@code null&#125;) */ ClassFilter getClassFilter(); /** * Return the MethodMatcher for this pointcut. * @return the MethodMatcher (never &#123;@code null&#125;) */ MethodMatcher getMethodMatcher(); /** * Canonical Pointcut instance that always matches. */ Pointcut TRUE = TruePointcut.INSTANCE;&#125; 可以看出 pointcut 接口分成 `类型匹配` 和 `方法匹配` 两个部分, 它们共同实现了切点的识别; ClassFilter 接口: ClassFilter 用来指定需要切入的目标类型。其接口定义如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445 /* * Copyright 2002-2007 the original author or authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.springframework.aop;/** * Filter that restricts matching of a pointcut or introduction to * a given set of target classes. * * &lt;p&gt;Can be used as part of a &#123;@link Pointcut&#125; or for the entire * targeting of an &#123;@link IntroductionAdvisor&#125;. * * @author Rod Johnson * @see Pointcut * @see MethodMatcher */public interface ClassFilter &#123; /** * Should the pointcut apply to the given interface or target class? * @param clazz the candidate target class * @return whether the advice should apply to the given target class */ boolean matches(Class&lt;?&gt; clazz); /** * Canonical instance of a ClassFilter that matches all classes. */ ClassFilter TRUE = TrueClassFilter.INSTANCE;&#125; 如果 matches 方法返回 `true` 则对应的类将被选中为通知类型; MethodMatcher 接口: MethodMatcher 接口是一个更为重要的接口, 其具体实现如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697 /* * Copyright 2002-2012 the original author or authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.springframework.aop;import java.lang.reflect.Method;/** * Part of a &#123;@link Pointcut&#125;: Checks whether the target method is eligible for advice. * * &lt;p&gt;A MethodMatcher may be evaluated &lt;b&gt;statically&lt;/b&gt; or at &lt;b&gt;runtime&lt;/b&gt; (dynamically). * Static matching involves method and (possibly) method attributes. Dynamic matching * also makes arguments for a particular call available, and any effects of running * previous advice applying to the joinpoint. * * &lt;p&gt;If an implementation returns &#123;@code false&#125; from its &#123;@link #isRuntime()&#125; * method, evaluation can be performed statically, and the result will be the same * for all invocations of this method, whatever their arguments. This means that * if the &#123;@link #isRuntime()&#125; method returns &#123;@code false&#125;, the 3-arg * &#123;@link #matches(java.lang.reflect.Method, Class, Object[])&#125; method will never be invoked. * * &lt;p&gt;If an implementation returns &#123;@code true&#125; from its 2-arg * &#123;@link #matches(java.lang.reflect.Method, Class)&#125; method and its &#123;@link #isRuntime()&#125; method * returns &#123;@code true&#125;, the 3-arg &#123;@link #matches(java.lang.reflect.Method, Class, Object[])&#125; * method will be invoked &lt;i&gt;immediately before each potential execution of the related advice&lt;/i&gt;, * to decide whether the advice should run. All previous advice, such as earlier interceptors * in an interceptor chain, will have run, so any state changes they have produced in * parameters or ThreadLocal state will be available at the time of evaluation. * * @author Rod Johnson * @since 11.11.2003 * @see Pointcut * @see ClassFilter */public interface MethodMatcher &#123; /** * Perform static checking whether the given method matches. If this * returns &#123;@code false&#125; or if the &#123;@link #isRuntime()&#125; method * returns &#123;@code false&#125;, no runtime check (i.e. no. * &#123;@link #matches(java.lang.reflect.Method, Class, Object[])&#125; call) will be made. * @param method the candidate method * @param targetClass the target class (may be &#123;@code null&#125;, in which case * the candidate class must be taken to be the method's declaring class) * @return whether or not this method matches statically */ boolean matches(Method method, Class&lt;?&gt; targetClass); /** * Is this MethodMatcher dynamic, that is, must a final call be made on the * &#123;@link #matches(java.lang.reflect.Method, Class, Object[])&#125; method at * runtime even if the 2-arg matches method returns &#123;@code true&#125;? * &lt;p&gt;Can be invoked when an AOP proxy is created, and need not be invoked * again before each method invocation, * @return whether or not a runtime match via the 3-arg * &#123;@link #matches(java.lang.reflect.Method, Class, Object[])&#125; method * is required if static matching passed */ boolean isRuntime(); /** * Check whether there a runtime (dynamic) match for this method, * which must have matched statically. * &lt;p&gt;This method is invoked only if the 2-arg matches method returns * &#123;@code true&#125; for the given method and target class, and if the * &#123;@link #isRuntime()&#125; method returns &#123;@code true&#125;. Invoked * immediately before potential running of the advice, after any * advice earlier in the advice chain has run. * @param method the candidate method * @param targetClass the target class (may be &#123;@code null&#125;, in which case * the candidate class must be taken to be the method's declaring class) * @param args arguments to the method * @return whether there's a runtime match * @see MethodMatcher#matches(Method, Class) */ boolean matches(Method method, Class&lt;?&gt; targetClass, Object[] args); /** * Canonical instance that matches all methods. */ MethodMatcher TRUE = TrueMethodMatcher.INSTANCE;&#125; 当创建 proxy 对象时， `matches(Method method, Class&lt;?&gt; targetClass);`方法将被调用，该方法用于判断当前类的方法是否为切入点， 这个方法不会在目标对象被调用时执行。当 该方法返回true 且 isRuntime()方法返回 true时，每次调用目标对象的该方法都会触发 matches(Method method, Class&lt;?&gt; targetClass, Object[] args) 方法的调用， 此时会判断参数信息是否符合切入点匹配规则。大部分 MethodMatcher 都是静态的，这意味着 isRuntime()方法都是返回false,这样的Matcher将不会在目标对象调用时检测方法是否匹配切入规则。 1.2 对Pointcut的操作: spring 支持对 Pointcut 进行交并补操作: 交集操作意味着一个方法必须被所有的 pointcut 匹配通过; 并集操作意味着一个方法只需被任意一个 pointcut 匹配通过; 1.3 方便的 Pointcut 现有类实现: spring 提供了一系列Pointcut实例类,一些开箱即用，一些需要根据特定的应用场景集成实现特定的实例类。 静态 pointcut: 静态 pointcut 不基于方法调用时传入参数作为切点判断依据。它们只在 代理对象初始化时对类方法进行切入评估，因此更高效。以下是一些静态 pointcut 的实例类; 动态 pointcut: 相对于静态pointcut, 动态pointcut基于调用时传入的参数或其他运行时信息(如堆栈信息)评估方法切入。因此动态 pointcut 将在每次方法调用时进行评估，其消耗型相对较高; 2. Advice API2.1 advice 的生命周期:advice 可以分成 per-class 和 per-instance 两种。 per-class Advice 生命周期: 这种类型的Advice是无状态的，他只基于方法和参数实现通知逻辑，因此它可以被多个被通知对象共享。 per-instance Advice 生命周期: 这种类型的 Advice 通过特定的状态信息实现一些高级功能，因此其生命周期和具体的被代理实例对象相对应。 2.2 spring 中的 Advice:spring 提供了一系列开箱即用的 Advice 类型: interception around advice: 1234567public class DebugInterceptor implements MethodInterceptor &#123; public Object invoke( MethodInvocation invocation) throws Throwable &#123; System.out.println("Before: invocation=[" + invocation + "]"); Object rval = invocation.proceed(); System.out.println("Invocation returned"); return rval; &#125; &#125; Before advice 1234567891011public class CountingBeforeAdvice implements MethodBeforeAdvice &#123; private int count; public void before(Method m, Object[] args, Object target) throws Throwable &#123; ++count; &#125; public int getCount() &#123; return count; &#125; &#125; Throws advice 123456789101112public static class CombinedThrowsAdvice implements ThrowsAdvice &#123; public void afterThrowing( RemoteException ex) throws Throwable &#123; // Do something with remote exception &#125; public void afterThrowing( Method m, Object[] args, Object target, ServletException ex&#123; // Do something with all arguments &#125;&#125; After Returning advice 12345678910111213 public class CountingAfterReturningAdvice implements AfterReturningAdvice &#123; private int count; public void afterReturning( Object returnValue, Method m, Object[] args, Object target) throws Throwable &#123; ++count; &#125; public int getCount() &#123; return count; &#125;&#125; Introduction advice 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * 引入接口定义 */public interface Lockable &#123; void lock(); void unlock(); boolean locked(); &#125;/** * IntroductionIntecptor 定义 * IntroductionIntecptor 需要实现被引入的接口 * invoke 方法定义了拦截逻辑（覆写可选） */ public class LockMixin extends DelegatingIntroductionInterceptor implements Lockable &#123; private boolean locked; public void lock() &#123; this.locked = true; &#125; public void unlock() &#123; this.locked = false; &#125; public boolean locked() &#123; return this.locked; &#125; public Object invoke(MethodInvocation invocation) throws Throwable &#123; if (locked() &amp;&amp; invocation.getMethod().getName().indexOf("set") == 0) &#123; throw new LockedException(); &#125; return super.invoke(invocation); &#125; &#125;/** * IntroductionAdvisor 定义 * IntroductionAdvisor 定义了 引入接口 和 默认IntroductionIntecptor实例类 */public class LockMixinAdvisor extends DefaultIntroductionAdvisor &#123; public LockMixinAdvisor() &#123; super(new LockMixin(), Lockable.class); &#125;&#125; 3. Advisor APIspring 中，advisor 是包含了 advice 和 pointcut 的切面组合。除了特殊的 Introduction advice（引入通知），任何advisor可以使用任何advice。DefaultPointcutAdvisor 是使用最频繁的 advisor。]]></content>
    </entry>

    
  
  
</search>
