<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[CGLIB 动态代理初讲]]></title>
      <url>%2F2017%2F02%2F07%2FCGLIB-1%2F</url>
      <content type="text"><![CDATA[简述: CGLIB (Code Generation Library) 底层基于 ASM 字节码处理框架, 能够在运行时生成新的java字节码，因此在动态代理方面使用广泛。相对于 JDK 原生动态代理, 它无需依赖接口，能够对任意类生成代理对象。 一、CGLIB 实现动态代理的一般步骤 在 CGLIB 中存在一个关键类 Enhancer。众所周知，代理要对原有对象对外暴露功能进行托管和增强，对于一个业务对象，狭义上的对外契约可以认为是业务接口，但是广义而言，任意对象的 public 方法都可以认为是暴露于外部的契约。因此在 CGLIB 中，其代理类的创建可以依赖任意类(区别于 JDK 原生动态代理 的面向接口代理)。 CGLIB 动态代理实现的简单步骤如下: 123456Enhancer enhancer = new Enhancer(); // 创建增强器enhancer.setSuperclass(businessObject.getClass()); // 设置被代理类enhancer.setCallback(callBackLogic); // 设置代理逻辑Business businessProxy = (Business)enhancer.create(); // 创建代理对象 businessProxy.doBusiness(); // 业务调用 上面步骤中 callBackLogic 是代理逻辑调用器对象，定义了具体代理切入逻辑、方法调用方式等，为 CGLIB 中 Callback 接口的实例。CGLIB 中有许多不同的 CallBack 子接口，对应了各种不同功能的代理逻辑。 CallBack 子接口展示: 二、CGLIB 动态代理实现样例老话讲,唯有实战才是磨炼技能的唯一标准，接下来我们根据一些简单样例分析 CGLIB 的特性: 依赖配置 maven 依赖配置: 1234567&lt;!--cglib maven 依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;cglib&lt;/groupId&gt; &lt;artifactId&gt;cglib&lt;/artifactId&gt; &lt;version&gt;3.2.4&lt;/version&gt;&lt;/dependency&gt; FixedValue 代理逻辑调用器 功能介绍: FixedValue 增强器将为目标类(包含目标类的父类)的所有方法(准确而言应该是非static且非final的public方法)设置固定返回值。在代理对象调用任一方法时,预设置的返回值将被强制转换成对应方法定义的返回值类型。因此，当类型无法强制转换时会抛出 ClassCastException 异常; 样例代码展示: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import net.sf.cglib.proxy.Enhancer;import net.sf.cglib.proxy.FixedValue;/** * FixedValue 测试 */public class CglibFixedValue &#123; public static void testFixedValue() &#123; Business business = new Business(); /** * 初始化增强器 * */ Enhancer enhancer = new Enhancer(); // 创建增强器 enhancer.setSuperclass(business.getClass()); enhancer.setCallback((FixedValue) () -&gt; "do business by proxy"); /** * 创建代理对象 * */ Business businessPrxy = (Business) enhancer.create(); System.out.println(business.doBusiness()); System.out.println(businessPrxy.doBusiness()); // System.out.println(businessPrxy.hashCode()); // err: ClassCastException /** * 创建代理增强类的类型 * */ Class cls = enhancer.createClass(); System.out.println(cls.getSuperclass().equals(business.getClass())); // Date datePrxy = (Date) enhancer.create(); // err: ClassCastException &#125; public static void main(String... args) &#123; testFixedValue(); &#125; /** 业务类定义 */ private static class Business &#123; public Business() &#123; &#125; // 静态方法 public static String staticDoBusiness() &#123; return "staticDoBusiness"; &#125; public String doBusiness() &#123; return "doBusiness"; &#125; final public String finalDoBusiness() &#123; return "finalDoBusiness"; &#125; private String privateDoBusiness()&#123; return "privateDoBusiness"; &#125; protected String protectedDoBusiness()&#123; return "protectedDoBusiness"; &#125; &#125;&#125; 运行结果如下: 1234非代理对象业务调用: doBusiness业务方法代理调用: do business by proxy父类方法代理调用: do business by proxy代理增强类是否是业务类的子类: true 正如开始描述，FixedValue 将会设置目标类及其父类中的方法返回固定值。代码样例中注释部分调用将产生类型转换异常。需要注意的是Business 类中定义了静态方法(staticDoBusiness),final方法(finalDoBusiness),private方法(privateDoBusiness)和protected方法(protectedDoBusiness),我在debug模式使用控制台监控器调用结果如下: 显然这些方法都未被代理重写。这是因为 CGLIB 只会对 非final且非static的public方法 进行代理逻辑重写。 InvocationHandler 代理逻辑调用器 CGLIB 和 JDK原生动态代理 一样也支持 InvocationHandler 形式的动态代理, 其实现样例如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import net.sf.cglib.proxy.Enhancer;import net.sf.cglib.proxy.InvocationHandler;import java.lang.reflect.Method;/** * invocationHandler 代理逻辑调用器 */public class CglibInvocationHandler &#123; public static void main(String... args) &#123; Business business = new Business(); Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(business.getClass()); enhancer.setCallback(new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; Object rt = null; System.out.println("do before business"); if (method.getReturnType().equals(String.class)) &#123; rt = method.invoke(business, args); &#125; else &#123; rt = "未知调用"; /** * 不能直接调用proxy对象的method方法, 将会产生死循环 * */ // method.invoke(proxy, args); &#125; System.out.println("do after business"); return rt; &#125; &#125;); Business businessProxy = (Business) enhancer.create(); businessProxy.doBusiness(); &#125; /** * 业务类 */ private static class Business &#123; public Business() &#123; &#125; public String doBusiness() &#123; System.out.println("do business"); return "do business"; &#125; &#125;&#125; 从样例代码中可以看出，和 JDK原生动态代理 一样，代理逻辑都是覆写 InvocationHandler 接口中的 invoke 方法实现的。需要注意的是，对原始方法的调用必须显式引入具体被代理的对象(业务对象)，对代理对象proxy直接使用method.invoke(proxy, args)进行方法调用将产生无限死循环!回顾一下JDK原生动态代理，应该也存在类似的问题。因此 InvocationHandler 在实际应用场景下并不常用，接下来介绍的 MethodInterceptor 将会解决这个问题。 MethodInterceptor 代理逻辑调用器 MethodInterceptor 代理逻辑调用器是最常用的代理方式，其调用样例如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import net.sf.cglib.proxy.Enhancer;import net.sf.cglib.proxy.MethodInterceptor;import net.sf.cglib.proxy.MethodProxy;import java.lang.reflect.Method;/** * MethodInterceptor 代理逻辑调用器 */public class CglibMethodInterceptor &#123; public static void main(String... args) &#123; Business business = new Business(); Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(business.getClass()); enhancer.setCallback(new MethodInterceptor() &#123; @Override public Object intercept( Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123; Object rt; System.out.println("===\ndo before business"); if (method.getReturnType().equals(String.class)) &#123; rt = proxy.invokeSuper(obj, args); // 调用原始方法(被代理业务对象的方法) &#125; else &#123; rt = "未知调用"; System.out.println(rt); &#125; System.out.println("do after business"); return rt; &#125; &#125;); Business businessProxy = (Business) enhancer.create(); System.out.println(businessProxy.doBusiness()); businessProxy.doBusiness("do business"); &#125; /** * 业务类 */ private static class Business &#123; public Business() &#123; &#125; public String doBusiness() &#123; System.out.println("do business"); return "business return value"; &#125; public void doBusiness(String arg) &#123; System.out.println(arg); &#125; &#125;&#125; 和 InvocationHandler 对比而言，其代理方法 intercept 的参数列表中多出一个 MethodProxy proxy 参数。proxy 参数是被代理类托管方法的封装。样例中 proxy.invokeSuper(obj, args); 这句代码就实现了对原始方法的调用，特别指出的是该调用并不依赖原始对象的引用（其中的obj对象是代理对象），也不会像 InvocationHandler 一样造成 invoke 死循环风险。 上面样例执行结果如下: 123456789===do before businessdo businessdo after businessbusiness return value===do before business未知调用do after business 码字太累，还剩几个调用器后续再补充完整(欢~迎~打~赏~) ^ ^ 三、CGLIB 动态代理特点归纳和总结简单列一下 CGLIB 代理的特点作为参考吧: CGLIB 的代理实现需要依赖第三方库; CGLIB 支持类级别的代理(相对于 JDK 动态代理 更为方便); CGLIB 只支持对 非static且非final的public方法 进行代理; CGLIB 支持多种代理逻辑调用器，可以实现丰富的代理，分发功能（后续会做更详细介绍）; 个人认为 CGLIB 代理实现上更直观简洁; 不难发现 CGLIB 的 代理逻辑 和 代理装配逻辑 也相互隔离，而装配逻辑可能在运行时才确定。因此 CGLIB 和 JDK原生动态代理 一样也是运行时实现代理生成的。但相较而言，使用 CGLIB 实现动态代理会更方便，更安全。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JDK 动态代理机制]]></title>
      <url>%2F2017%2F02%2F06%2FJDK-proxy%2F</url>
      <content type="text"><![CDATA[简述JDK 动态代理是一种基于反射的运行时逻辑切入。实现简单，但只作用于接口级别。以下示例将一步步演示其实现过程并分析其实现特点及应用场景。 一、java 动态代理实现简述- UML 类图描述: 类图分析: 从类图关系可以看出，代理逻辑(ProxyHandler)和业务逻辑(BusinessImpl)在定义时是相互独立的。 代理对象是由Proxy.newProxyInstance() 方法生成, 该方法强依赖于 代理逻辑实例(InvocationHandler实例对象) 和 被代理业务接口(IBusiness)。 类图总结: 通过分析我们可以得出代理对象的创建必须依赖具体代理逻辑的定义和被代理接口的定义。创建代理的过程可以分为如下几步: 定义并明确需要被代理的业务接口; 实现 InvocationHandler 接口，创建代理逻辑实例类; 通过 Proxy.newProxyInstance() 方法创建具体代理对象 需要注意的是 InvocationHandler 实例类也依赖具体的业务对象，因为在代理进行方法调用时必须明确自己代理的目标对象是什么。 二、JDK 动态代理样例实现- 定义业务接口和业务实现类业务接口和实现类完全根据业务需求进行定义和实现，这里只做简单 demo 演示，故只是实现了一个简介的 doBusiness 方法: 业务接口: 123456789101112131415/** * 业务接口 */public interface IBusiness &#123; /** * 业务方法 * * @param business 业务参数 * @return 执行成功返回 true, 失败返回 false * @throws IllegalArgumentException 参数异常时抛出 */ public Boolean doBusiness(String business) throws IllegalArgumentException;&#125; 业务实例类: 1234567891011121314151617181920212223import org.apache.commons.lang3.Validate;/** * 业务细节实现类 */public class BusinessImpl implements IBusiness &#123; /** * 业务方法 * * @param business 业务参数 * @return 执行成功返回 true, 失败返回 false * @throws IllegalArgumentException 参数异常时抛出 */ public Boolean doBusiness( String business) throws IllegalArgumentException &#123; Validate.notBlank(business); // 参数校验 System.out.println("Do business: " + business); // 业务逻辑 return true; // 业务返回 &#125;&#125; - 代理逻辑定义(InvocationHandler实现)代理逻辑区别于普通业务逻辑，他可以是基于框架功能的抽象，也可以是更泛化的业务逻辑抽象，但是他的功能应该是明确的: 代理的存在一方面让具体业务实例在进行业务操作时更加纯粹(干净), 另外也使抽象逻辑的管理更加统一。 常见的代理逻辑如: 调用日志记录，监控打点，会话管理，资源回收 等。这里我们只做简单的打印实现（主要是方便观察效果 ^^）: 12345678910111213141516171819202122232425262728293031323334353637383940414243import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;/** * 代理操作类 * * 其作用是定义具体的代理逻辑 */public class ProxyHandler implements InvocationHandler &#123; private Object businessObject; /** * 该案例通过构造函数设置被代理对象(可选) */ public ProxyHandler(Object businessObject) &#123; this.businessObject = businessObject; &#125; /** * 具体代理逻辑切入实现 * * 可以实现的功能: * * 1. 逻辑织入(调用前后增加非业务逻辑) * * 2. 控制调用姿势(根据上下文方法控制调用方式) * * 3. 返回值和异常控制 * * @param proxy 代理对象 * @param method 被调用的业务接口方法 * @param args 被调用业务接口方法的参数 */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println("Do something before method"); Object result = businessObject == null ? null : method.invoke(businessObject, args); System.out.println("Do something after method"); return result; &#125;&#125; 可以看出代理逻辑的实现还是比较简单清晰的，这里做了被调方法在调用前后的操作(打印)，方法调用时的判断操作以及返回值的传递操作。不难发现代理对调用的控制相当全面，他直接决定了方法是否真正调用。 需要注意的是: 因为基于反射的method方法调用必须依赖具体执行对象作为参数，所以调用逻辑在实现时也需要依赖具体的业务实例。（本例中在构造函数中引入实例引用，当然也可以以set方法的的形式传入，这样还可以达到意想不到的效果哦 ^ ^ ) - 代理对象的创建和使用(Proxy.newProxyInstance())豪爽的我直接上代码: 123456789101112131415161718192021222324import java.lang.reflect.Proxy;/** * JDK 动态代场景理测试 */public class ProxyTest &#123; public static void main(String... args) &#123; BusinessImpl business = new BusinessImpl(); // 业务对象实例 ProxyHandler proxyHandler = new ProxyHandler(business); // 代理逻辑执行器对象 /**创建代理对象*/ IBusiness businessProxy = (IBusiness) Proxy.newProxyInstance( business.getClass().getClassLoader(), new Class[]&#123;IBusiness.class&#125;, proxyHandler); businessProxy.doBusiness("business"); // 处理业务 &#125;&#125; 寥寥几行, 不要太简单！！代理对象的创建只需三个参数: 被代理对象的类加载器; 被代理的接口列表; 刚刚定义的代理逻辑实例对象; 接下来让我们看看执行效果: 123Do something before methodDo business: businessDo something after method 哈哈~ 代理逻辑已经完美执行! 三、JDK 动态代理特性分析上面已经说过，代理的存在一方面让具体业务实例在进行业务操作时更加纯粹(干净), 另外也使抽象逻辑的管理更加统一。需要指出的是 JDK 动态代理 只是众多代理实现方式中的一种，如在spring框架中，其AOP实现就综合了 JDK 动态代理 和 CGLIB 代理 。接下来让我们总结一下 JDK 动态代理 的特点: JDK 原生支持，无需依赖第三方库； JDK 动态代理 实质上为运行时通过代理对象间接调用目标对象方法达到逻辑切入目的（并不修改原有业务逻辑） 依赖业务接口。代理对象在生成时强依赖于被代理的业务接口，因此在使用过程中可能会增加不必要的接口定义（不支持方法粒度代理）。 代理逻辑实现方便，但也过于简陋。对于被代理对象，他的所有方法在调用时都会执行代理逻辑类中的invoke方法，这也说明在唯一的一个invoke方法中必须cover目标对象中所有方法的执行逻辑。很显然，当接口中存在代理逻辑不一致的方法时，这种方式很容易造成不必要的耦合，不便于代理逻辑开发维护（代理逻辑定义时容易耦合）。 四、总结 代理的应用在框架类型的项目开发中是很常见的，其重要性不言而喻。本篇简单介绍了原生的JDK 动态代理，其实现简单，逻辑清晰。可以看出在普通面向接口，切入逻辑简单且统一的代理实现上，JDK 动态代理是一个不错的选择，但是面对更细致的代理场景，如跨接口的方法级别代理需求，JDK 动态代理便显得余力不足了。后面的博文中向大家介绍一个方法级别的代理库—-CGLIB,它也是 spring AOP 代理实现中的重要一员。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[spring AOP APIs 简述]]></title>
      <url>%2F2017%2F02%2F04%2Fspring-AOP-APIs%2F</url>
      <content type="text"><![CDATA[1. Pointcut API1.1 接口定义: spring pointcut 用于将 advices 指向特定的类和方法。其具体定义如下: 12345678910111213141516171819202122232425262728293031323334353637package org.springframework.aop;/** * Core Spring pointcut abstraction. * * &lt;p&gt;A pointcut is composed of a &#123;@link ClassFilter&#125; and a &#123;@link MethodMatcher&#125;. * Both these basic terms and a Pointcut itself can be combined to build up combinations * (e.g. through &#123;@link org.springframework.aop.support.ComposablePointcut&#125;). * * @author Rod Johnson * @see ClassFilter * @see MethodMatcher * @see org.springframework.aop.support.Pointcuts * @see org.springframework.aop.support.ClassFilters * @see org.springframework.aop.support.MethodMatchers */public interface Pointcut &#123; /** * Return the ClassFilter for this pointcut. * @return the ClassFilter (never &#123;@code null&#125;) */ ClassFilter getClassFilter(); /** * Return the MethodMatcher for this pointcut. * @return the MethodMatcher (never &#123;@code null&#125;) */ MethodMatcher getMethodMatcher(); /** * Canonical Pointcut instance that always matches. */ Pointcut TRUE = TruePointcut.INSTANCE;&#125; 可以看出 pointcut 接口分成 `类型匹配` 和 `方法匹配` 两个部分, 它们共同实现了切点的识别; ClassFilter 接口: ClassFilter 用来指定需要切入的目标类型。其接口定义如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445 /* * Copyright 2002-2007 the original author or authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.springframework.aop;/** * Filter that restricts matching of a pointcut or introduction to * a given set of target classes. * * &lt;p&gt;Can be used as part of a &#123;@link Pointcut&#125; or for the entire * targeting of an &#123;@link IntroductionAdvisor&#125;. * * @author Rod Johnson * @see Pointcut * @see MethodMatcher */public interface ClassFilter &#123; /** * Should the pointcut apply to the given interface or target class? * @param clazz the candidate target class * @return whether the advice should apply to the given target class */ boolean matches(Class&lt;?&gt; clazz); /** * Canonical instance of a ClassFilter that matches all classes. */ ClassFilter TRUE = TrueClassFilter.INSTANCE;&#125; 如果 matches 方法返回 `true` 则对应的类将被选中为通知类型; MethodMatcher 接口: MethodMatcher 接口是一个更为重要的接口, 其具体实现如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697 /* * Copyright 2002-2012 the original author or authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.springframework.aop;import java.lang.reflect.Method;/** * Part of a &#123;@link Pointcut&#125;: Checks whether the target method is eligible for advice. * * &lt;p&gt;A MethodMatcher may be evaluated &lt;b&gt;statically&lt;/b&gt; or at &lt;b&gt;runtime&lt;/b&gt; (dynamically). * Static matching involves method and (possibly) method attributes. Dynamic matching * also makes arguments for a particular call available, and any effects of running * previous advice applying to the joinpoint. * * &lt;p&gt;If an implementation returns &#123;@code false&#125; from its &#123;@link #isRuntime()&#125; * method, evaluation can be performed statically, and the result will be the same * for all invocations of this method, whatever their arguments. This means that * if the &#123;@link #isRuntime()&#125; method returns &#123;@code false&#125;, the 3-arg * &#123;@link #matches(java.lang.reflect.Method, Class, Object[])&#125; method will never be invoked. * * &lt;p&gt;If an implementation returns &#123;@code true&#125; from its 2-arg * &#123;@link #matches(java.lang.reflect.Method, Class)&#125; method and its &#123;@link #isRuntime()&#125; method * returns &#123;@code true&#125;, the 3-arg &#123;@link #matches(java.lang.reflect.Method, Class, Object[])&#125; * method will be invoked &lt;i&gt;immediately before each potential execution of the related advice&lt;/i&gt;, * to decide whether the advice should run. All previous advice, such as earlier interceptors * in an interceptor chain, will have run, so any state changes they have produced in * parameters or ThreadLocal state will be available at the time of evaluation. * * @author Rod Johnson * @since 11.11.2003 * @see Pointcut * @see ClassFilter */public interface MethodMatcher &#123; /** * Perform static checking whether the given method matches. If this * returns &#123;@code false&#125; or if the &#123;@link #isRuntime()&#125; method * returns &#123;@code false&#125;, no runtime check (i.e. no. * &#123;@link #matches(java.lang.reflect.Method, Class, Object[])&#125; call) will be made. * @param method the candidate method * @param targetClass the target class (may be &#123;@code null&#125;, in which case * the candidate class must be taken to be the method's declaring class) * @return whether or not this method matches statically */ boolean matches(Method method, Class&lt;?&gt; targetClass); /** * Is this MethodMatcher dynamic, that is, must a final call be made on the * &#123;@link #matches(java.lang.reflect.Method, Class, Object[])&#125; method at * runtime even if the 2-arg matches method returns &#123;@code true&#125;? * &lt;p&gt;Can be invoked when an AOP proxy is created, and need not be invoked * again before each method invocation, * @return whether or not a runtime match via the 3-arg * &#123;@link #matches(java.lang.reflect.Method, Class, Object[])&#125; method * is required if static matching passed */ boolean isRuntime(); /** * Check whether there a runtime (dynamic) match for this method, * which must have matched statically. * &lt;p&gt;This method is invoked only if the 2-arg matches method returns * &#123;@code true&#125; for the given method and target class, and if the * &#123;@link #isRuntime()&#125; method returns &#123;@code true&#125;. Invoked * immediately before potential running of the advice, after any * advice earlier in the advice chain has run. * @param method the candidate method * @param targetClass the target class (may be &#123;@code null&#125;, in which case * the candidate class must be taken to be the method's declaring class) * @param args arguments to the method * @return whether there's a runtime match * @see MethodMatcher#matches(Method, Class) */ boolean matches(Method method, Class&lt;?&gt; targetClass, Object[] args); /** * Canonical instance that matches all methods. */ MethodMatcher TRUE = TrueMethodMatcher.INSTANCE;&#125; 当创建 proxy 对象时， `matches(Method method, Class&lt;?&gt; targetClass);`方法将被调用，该方法用于判断当前类的方法是否为切入点， 这个方法不会在目标对象被调用时执行。当 该方法返回true 且 isRuntime()方法返回 true时，每次调用目标对象的该方法都会触发 matches(Method method, Class&lt;?&gt; targetClass, Object[] args) 方法的调用， 此时会判断参数信息是否符合切入点匹配规则。大部分 MethodMatcher 都是静态的，这意味着 isRuntime()方法都是返回false,这样的Matcher将不会在目标对象调用时检测方法是否匹配切入规则。 1.2 对Pointcut的操作: spring 支持对 Pointcut 进行交并补操作: 交集操作意味着一个方法必须被所有的 pointcut 匹配通过; 并集操作意味着一个方法只需被任意一个 pointcut 匹配通过; 1.3 方便的 Pointcut 现有类实现: spring 提供了一系列Pointcut实例类,一些开箱即用，一些需要根据特定的应用场景集成实现特定的实例类。 静态 pointcut: 静态 pointcut 不基于方法调用时传入参数作为切点判断依据。它们只在 代理对象初始化时对类方法进行切入评估，因此更高效。以下是一些静态 pointcut 的实例类; 动态 pointcut: 相对于静态pointcut, 动态pointcut基于调用时传入的参数或其他运行时信息(如堆栈信息)评估方法切入。因此动态 pointcut 将在每次方法调用时进行评估，其消耗型相对较高; 2. Advice API2.1 advice 的生命周期:advice 可以分成 per-class 和 per-instance 两种。 per-class Advice 生命周期: 这种类型的Advice是无状态的，他只基于方法和参数实现通知逻辑，因此它可以被多个被通知对象共享。 per-instance Advice 生命周期: 这种类型的 Advice 通过特定的状态信息实现一些高级功能，因此其生命周期和具体的被代理实例对象相对应。 2.2 spring 中的 Advice:spring 提供了一系列开箱即用的 Advice 类型: interception around advice: 1234567public class DebugInterceptor implements MethodInterceptor &#123; public Object invoke( MethodInvocation invocation) throws Throwable &#123; System.out.println("Before: invocation=[" + invocation + "]"); Object rval = invocation.proceed(); System.out.println("Invocation returned"); return rval; &#125; &#125; Before advice 1234567891011public class CountingBeforeAdvice implements MethodBeforeAdvice &#123; private int count; public void before(Method m, Object[] args, Object target) throws Throwable &#123; ++count; &#125; public int getCount() &#123; return count; &#125; &#125; Throws advice 123456789101112public static class CombinedThrowsAdvice implements ThrowsAdvice &#123; public void afterThrowing( RemoteException ex) throws Throwable &#123; // Do something with remote exception &#125; public void afterThrowing( Method m, Object[] args, Object target, ServletException ex&#123; // Do something with all arguments &#125;&#125; After Returning advice 12345678910111213 public class CountingAfterReturningAdvice implements AfterReturningAdvice &#123; private int count; public void afterReturning( Object returnValue, Method m, Object[] args, Object target) throws Throwable &#123; ++count; &#125; public int getCount() &#123; return count; &#125;&#125; Introduction advice 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * 引入接口定义 */public interface Lockable &#123; void lock(); void unlock(); boolean locked(); &#125;/** * IntroductionIntecptor 定义 * IntroductionIntecptor 需要实现被引入的接口 * invoke 方法定义了拦截逻辑（覆写可选） */ public class LockMixin extends DelegatingIntroductionInterceptor implements Lockable &#123; private boolean locked; public void lock() &#123; this.locked = true; &#125; public void unlock() &#123; this.locked = false; &#125; public boolean locked() &#123; return this.locked; &#125; public Object invoke(MethodInvocation invocation) throws Throwable &#123; if (locked() &amp;&amp; invocation.getMethod().getName().indexOf("set") == 0) &#123; throw new LockedException(); &#125; return super.invoke(invocation); &#125; &#125;/** * IntroductionAdvisor 定义 * IntroductionAdvisor 定义了 引入接口 和 默认IntroductionIntecptor实例类 */public class LockMixinAdvisor extends DefaultIntroductionAdvisor &#123; public LockMixinAdvisor() &#123; super(new LockMixin(), Lockable.class); &#125;&#125; 3. Advisor APIspring 中，advisor 是包含了 advice 和 pointcut 的切面组合。除了特殊的 Introduction advice（引入通知），任何advisor可以使用任何advice。DefaultPointcutAdvisor 是使用最频繁的 advisor。]]></content>
    </entry>

    
  
  
</search>
